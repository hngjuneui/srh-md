<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>웹 AI 핸드 트래킹 조종기</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: #f2f2f7;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: #1c1c1e;
      margin: 0;
    }

    .main-container {
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    h2 {
      font-size: 1.5em;
      color: #007aff;
      font-weight: 600;
      margin-bottom: 10px;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      max-width: 400px;
      height: 300px;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      background-color: #000;
    }

    canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }

    #camera-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #ffffff;
      font-size: 1em;
      text-align: center;
      border-radius: 16px;
    }

    #status-box {
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      background-color: #ffffff;
      border: 1px solid #ccc;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
      max-width: 400px;
      width: 100%;
      text-align: center;
      font-size: 0.9em;
      cursor: pointer;
    }

    pre#log {
      margin-top: 15px;
      background: #ffffff;
      padding: 14px 18px;
      width: 100%;
      max-width: 400px;
      height: 120px;
      overflow-y: auto;
      border-radius: 12px;
      border: 1px solid #d1d1d6;
      font-size: 0.8em;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
      white-space: pre-wrap;
    }

    button {
      width: 100%;
      max-width: 400px;
      padding: 12px;
      margin: 10px 0;
      border: none;
      border-radius: 12px;
      background-color: #007aff;
      color: white;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #005ecb;
    }

    video.hidden {
      display: none;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
</head>
<body>
  <h2>웹 AI 핸드 트래킹 조종기</h2>
  <div id="status-box">
    <div id="status">기기 연결 중...</div>
  </div>
  
  <div class="main-container">
    <div class="canvas-container" onclick="startCamera()">
      <canvas id="outputCanvas"></canvas>
      <div id="camera-placeholder">카메라를 시작하려면 터치하세요</div>
    </div>
  </div>
  
  <pre id="log"></pre>
  <video id="camera" autoplay playsinline class="hidden"></video>

  <script>
    let device;
    let writeCharacteristic;
    let lastGesture = null;
    let cameraStarted = false;

    const log = (msg) => {
      const el = document.getElementById('log');
      const timestamp = new Date().toLocaleTimeString();
      el.textContent += `[${timestamp}] ${msg}\n`;
      el.scrollTop = el.scrollHeight;
    };

    const updateStatus = (text) => {
      document.getElementById('status').textContent = '상태: ' + text;
    };

    // 페이지 로드 시 자동으로 BLE 검색
    window.addEventListener('load', () => {
      setTimeout(() => {
        connectBLE();
      }, 500);
    });

    async function connectBLE() {
      try {
        device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: ['00c0ffee-1234-1234-1234-123456789abc']
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService('00c0ffee-1234-1234-1234-123456789abc');
        writeCharacteristic = await service.getCharacteristic('00c0ffee-4321-4321-4321-cba987654321');
        log('BLE 연결 성공: ' + device.name);
        updateStatus('연결됨 (' + device.name + ')');

        device.addEventListener('gattserverdisconnected', () => {
          log('BLE 연결 끊김.');
          updateStatus('연결 끊김');
          writeCharacteristic = null;
        });
      } catch (e) {
        log('BLE 연결 실패: ' + e);
        updateStatus('화면을 터치하여 기기 검색...');
      }
    }

    function sendMessage(msg) {
      if (!writeCharacteristic) return;
      const encoder = new TextEncoder();
      writeCharacteristic.writeValue(encoder.encode(msg + '\n'))
        .then(() => log(`전송: ${msg}`))
        .catch(err => log(`전송 실패: ${err}`));
    }

    const videoElement = document.getElementById('camera');
    const canvasElement = document.getElementById('outputCanvas');
    const canvasCtx = canvasElement.getContext('2d');

    function adjustCanvasSize() {
      if (videoElement.videoWidth && videoElement.videoHeight) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
      }
    }

    // 손바닥 중앙점 계산 함수
    function calculatePalmCenter(landmarks) {
      // 손바닥의 주요 랜드마크들 (0: 손목, 5: 검지 MCP, 9: 중지 MCP, 13: 약지 MCP, 17: 새끼 MCP)
      const palmIndices = [0, 5, 9, 13, 17];
      let centerX = 0, centerY = 0;
      
      palmIndices.forEach(index => {
        centerX += landmarks[index].x;
        centerY += landmarks[index].y;
      });
      
      return {
        x: centerX / palmIndices.length,
        y: centerY / palmIndices.length
      };
    }

    // 제스처 인식 함수 (주먹 vs 펼친 손)
    function detectGesture(landmarks) {
      // 손가락 끝과 중간 관절들의 인덱스
      const fingerTips = [4, 8, 12, 16, 20]; // 엄지, 검지, 중지, 약지, 새끼
      const fingerMCPs = [3, 6, 10, 14, 18]; // 각 손가락의 MCP 관절
      
      let extendedFingers = 0;
      
      // 엄지 (x축 비교)
      if (Math.abs(landmarks[4].x - landmarks[3].x) > 0.04) {
        extendedFingers++;
      }
      
      // 나머지 손가락들 (y축 비교)
      for (let i = 1; i < 5; i++) {
        if (landmarks[fingerTips[i]].y < landmarks[fingerMCPs[i]].y - 0.02) {
          extendedFingers++;
        }
      }
      
      return extendedFingers >= 3 ? 'open' : 'fist';
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults(results => {
      adjustCanvasSize();
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.translate(canvasElement.width, 0);
      canvasCtx.scale(-1, 1);
      canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0]; // 첫 번째 손만 사용
        
        // 손바닥 중앙점 계산
        const palmCenter = calculatePalmCenter(landmarks);
        const centerX = Math.round(palmCenter.x * canvasElement.width);
        const centerY = Math.round(palmCenter.y * canvasElement.height);
        
        // 손바닥 중앙 좌표 실시간 전송
        sendMessage(`${centerX},${centerY}`);
        
        // 제스처 인식
        const currentGesture = detectGesture(landmarks);
        
        // 제스처 변화 감지 시 'a' 전송
        if (lastGesture !== null && lastGesture !== currentGesture) {
          sendMessage('a');
          log(`제스처 변화: ${lastGesture} -> ${currentGesture}`);
        }
        lastGesture = currentGesture;
        
        // 손 랜드마크 그리기
        canvasCtx.strokeStyle = '#00ff00';
        canvasCtx.lineWidth = 2;
        canvasCtx.fillStyle = '#ff0000';
        
        // 랜드마크 점들 그리기
        landmarks.forEach((landmark, index) => {
          const x = landmark.x * canvasElement.width;
          const y = landmark.y * canvasElement.height;
          
          canvasCtx.beginPath();
          canvasCtx.arc(x, y, 3, 0, 2 * Math.PI);
          canvasCtx.fill();
        });
        
        // 손바닥 중앙점 강조 표시
        canvasCtx.fillStyle = '#0000ff';
        canvasCtx.beginPath();
        canvasCtx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
        canvasCtx.fill();
        
        // 연결선 그리기
        const connections = [
          [0, 1], [1, 2], [2, 3], [3, 4], // 엄지
          [0, 5], [5, 6], [6, 7], [7, 8], // 검지
          [0, 9], [9, 10], [10, 11], [11, 12], // 중지
          [0, 13], [13, 14], [14, 15], [15, 16], // 약지
          [0, 17], [17, 18], [18, 19], [19, 20], // 새끼
          [0, 17], [5, 9], [9, 13], [13, 17] // 손바닥
        ];
        
        connections.forEach(([start, end]) => {
          const startPoint = landmarks[start];
          const endPoint = landmarks[end];
          
          canvasCtx.beginPath();
          canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
          canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
          canvasCtx.stroke();
        });
        
      } else {
        lastGesture = null;
      }

      canvasCtx.restore();
    });

    async function startCamera() {
      if (cameraStarted) return;
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
        videoElement.srcObject = stream;
        videoElement.play();
        
        videoElement.onloadedmetadata = () => {
          adjustCanvasSize();
          // 카메라가 준비되면 플레이스홀더 숨기고 캔버스 표시
          document.getElementById('camera-placeholder').style.display = 'none';
          canvasElement.style.display = 'block';
          
          const camera = new Camera(videoElement, {
            onFrame: async () => {
              await hands.send({ image: videoElement });
            },
            width: 480,
            height: 640
          });
          
          camera.start();
          cameraStarted = true;
          log('카메라 시작됨');
        };
        
      } catch (error) {
        log('카메라 시작 실패: ' + error);
      }
    }

    // status 박스 클릭 시 기기 검색 팝업 띄우기
    document.getElementById('status-box').addEventListener('click', () => {
      connectBLE();
    });
  </script>

  <div style="width: 100%; max-width: 400px; text-align: center; padding: 10px 0; margin-top: 20px; font-size: 0.8em; color: #8e8e93;">
    <hr style="border: none; border-top: 1px solid #d1d1d6; margin: 10px 0;">
    2025 Teacher Jun, Dept. of Robotics Mechanical Design, Seoul Robotics Highschool
  </div>
</body>
</html>
