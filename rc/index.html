<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>웹 AI 포즈 모델 조종기</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: #1c1c1e;
      margin: 0;
      min-height: 100vh;
    }

    .main-container {
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    h2 {
      font-size: 1.5em;
      color: #ffffff;
      font-weight: 600;
      margin-bottom: 10px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .canvas-container {
      position: relative;
      width: 100%;
      max-width: 400px;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    canvas {
      max-width: 100%;
      width: 100%;
      height: auto;
      display: block;
    }

    #status-box {
      margin-top: 15px;
      padding: 15px 20px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      max-width: 400px;
      width: 100%;
      text-align: center;
      font-size: 0.9em;
      font-weight: 500;
    }

    #speed-display {
      margin-top: 15px;
      padding: 20px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      color: #1c1c1e;
      max-width: 400px;
      width: 100%;
      text-align: center;
      font-size: 1.3em;
      font-weight: 700;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    pre#log {
      margin-top: 15px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 16px 20px;
      width: 100%;
      max-width: 400px;
      height: 120px;
      overflow-y: auto;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      font-size: 0.85em;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      white-space: pre-wrap;
      font-family: 'Monaco', 'Courier New', monospace;
    }

    button {
      width: 100%;
      max-width: 400px;
      padding: 12px;
      margin: 10px 0;
      border: none;
      border-radius: 12px;
      background-color: #007aff;
      color: white;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #005ecb;
    }

    video.hidden {
      display: none;
    }

    .footer {
      width: 100%; 
      max-width: 400px; 
      text-align: center; 
      padding: 20px 0; 
      margin-top: 30px; 
      font-size: 0.75em; 
      color: rgba(255, 255, 255, 0.7);
    }

    .footer hr {
      border: none; 
      border-top: 1px solid rgba(255, 255, 255, 0.2); 
      margin: 15px 0;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
</head>
<body>
  <h2>웹 AI 포즈 모델 조종기</h2>
  <div id="status-box">
    <div id="status">화면을 터치하여 기기 검색...</div>
  </div>
  
  <div class="main-container">
    <div class="canvas-container">
      <canvas id="outputCanvas"></canvas>
    </div>
  </div>
  
  <div id="speed-display">속도: 0단계 | 방향: 정지 | 서보: OFF</div>
  
  <pre id="log"></pre>
  <video id="camera" autoplay playsinline class="hidden"></video>

  <script>
    let device;
    let writeCharacteristic;
    
    // 상태 변수
    let currentSpeed = 0;
    let lastCommand = '정지';
    let servoState = 'OFF';
    let lastDistance = 0;
    let mouthOpen = false;
    
    // 명령 전송 제어 (중복 방지)
    let lastSentCommand = '';
    let lastSentTime = 0;
    const COMMAND_THROTTLE = 100; // ms

    // 색상 테마 (세련된 파스텔/모던 톤)
    const COLORS = {
      forward: '#FF6B6B',      // 코랄 레드
      backward: '#4ECDC4',     // 터쿼이즈
      turnLeft: '#FFE66D',     // 소프트 옐로우
      turnRight: '#A8E6CF',    // 민트 그린
      stop: '#95A5A6',         // 그레이
      mouthClosed: '#2C3E50',  // 다크 네이비
      mouthOpen: '#E74C3C'     // 브릿지 레드
    };

    const log = (msg) => {
      const el = document.getElementById('log');
      const timestamp = new Date().toLocaleTimeString('ko-KR');
      el.textContent += `[${timestamp}] ${msg}\n`;
      el.scrollTop = el.scrollHeight;
    };

    const updateStatus = (text) => {
      document.getElementById('status').textContent = '상태: ' + text;
    };

    const updateDisplay = () => {
      document.getElementById('speed-display').textContent = 
        `속도: ${currentSpeed}단계 | 방향: ${lastCommand} | 서보: ${servoState}`;
    };

    async function connectBLE() {
      try {
        device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: ['00c0ffee-1234-1234-1234-123456789abc']
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService('00c0ffee-1234-1234-1234-123456789abc');
        writeCharacteristic = await service.getCharacteristic('00c0ffee-4321-4321-4321-cba987654321');
        log('BLE 연결 성공: ' + device.name);
        updateStatus('연결됨 (' + device.name + ')');

        device.addEventListener('gattserverdisconnected', () => {
          log('BLE 연결 끊김');
          updateStatus('연결 끊김');
          writeCharacteristic = null;
        });
      } catch (e) {
        log('BLE 연결 실패: ' + e);
        updateStatus('연결 실패');
      }
    }

    function sendMessage(label, msg) {
      if (!writeCharacteristic) return;
      
      const now = Date.now();
      const key = label + msg;
      
      // 중복 명령 방지 (같은 명령이 100ms 이내에 재전송되지 않도록)
      if (key === lastSentCommand && now - lastSentTime < COMMAND_THROTTLE) {
        return;
      }
      
      lastSentCommand = key;
      lastSentTime = now;
      
      const encoder = new TextEncoder();
      writeCharacteristic.writeValue(encoder.encode(msg + '\n'))
        .then(() => log(`${label} → ${msg}`))
        .catch(err => log(`전송 실패: ${err}`));
    }

    const videoElement = document.getElementById('camera');
    const canvasElement = document.getElementById('outputCanvas');
    const canvasCtx = canvasElement.getContext('2d');

    function adjustCanvasSize() {
      if (videoElement.videoWidth && videoElement.videoHeight) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
      }
    }

    function getDistance(p1, p2) {
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getAngle(p1, p2) {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      return Math.atan2(dy, dx) * 180 / Math.PI;
    }

    function isMouthOpen(landmarks) {
      // 상순(upper lip): landmark 0
      // 하순(lower lip): landmark 17
      const upperLip = landmarks[0];
      const lowerLip = landmarks[17];
      const distance = getDistance(upperLip, lowerLip);
      
      // 임계값을 더 크게 조정 (입을 확실히 벌려야 인식)
      return distance > 0.025;
    }

    function isOutOfBounds(point) {
      return point.x < 0 || point.x > 1 || point.y < 0 || point.y > 1;
    }

    const pose = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    pose.onResults(results => {
      adjustCanvasSize();
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.translate(canvasElement.width, 0);
      canvasCtx.scale(-1, 1);
      canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

      if (results.poseLandmarks) {
        const landmarks = results.poseLandmarks;
        
        // 입 좌표는 코(landmark 0)를 사용
        const mouth = {
          x: landmarks[0].x,
          y: landmarks[0].y + 0.03,  // 코에서 약간 아래로 (입 위치)
          z: landmarks[0].z
        };

        // 입 상태 확인 및 표시 (주먹 인식과 독립적으로 처리)
        const mouthNowOpen = isMouthOpen(landmarks);
        let mouthColor = mouthNowOpen ? COLORS.mouthOpen : COLORS.mouthClosed;
        
        if (!mouthOpen && mouthNowOpen) {
          sendMessage('서보ON', '9');
          log('입 열림 → 서보 재구동');
          servoState = 'ON';
          updateDisplay();
        } else if (mouthOpen && !mouthNowOpen) {
          sendMessage('서보OFF', '7');
          log('입 닫힘 → 서보 구동');
          servoState = 'OFF';
          updateDisplay();
        }
        
        mouthOpen = mouthNowOpen;

        // 입 점 그리기 (항상 표시)
        const mx = mouth.x * canvasElement.width;
        const my = mouth.y * canvasElement.height;
        
        canvasCtx.beginPath();
        canvasCtx.arc(mx, my, 14, 0, 2 * Math.PI);
        canvasCtx.fillStyle = mouthColor;
        canvasCtx.fill();
        
        canvasCtx.beginPath();
        canvasCtx.arc(mx - 2, my - 2, 5, 0, 2 * Math.PI);
        canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        canvasCtx.fill();
        
        canvasCtx.beginPath();
        canvasCtx.arc(mx, my, 14, 0, 2 * Math.PI);
        canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        canvasCtx.lineWidth = 3;
        canvasCtx.stroke();

        // 손목 좌표를 주먹 위치로 조정 (y값을 올려서 손등 쪽으로)
        const leftFist = {
          x: landmarks[15].x,
          y: landmarks[15].y - 0.05,  // 위로 올림
          z: landmarks[15].z
        };
        const rightFist = {
          x: landmarks[16].x,
          y: landmarks[16].y - 0.05,  // 위로 올림
          z: landmarks[16].z
        };

        // 화면 밖 체크 (손만 체크, 입은 계속 작동)
        if (isOutOfBounds(leftFist) || isOutOfBounds(rightFist)) {
          if (currentSpeed !== 0 || lastCommand !== '정지') {
            currentSpeed = 0;
            lastCommand = '정지';
            sendMessage('화면이탈', '5');
            log('손이 화면 밖으로 이탈 → 정지');
            updateDisplay();
          }
          
          canvasCtx.restore();
          return;
        }

        // 거리 계산
        const distance = getDistance(leftFist, rightFist);
        
        // 임계값 설정
        const STOP_THRESHOLD = 0.12;      // 정지 시작 거리
        const DEADZONE_THRESHOLD = 0.16;  // 데드존 (이 거리까지는 정지 유지)
        const ANGLE_DEADZONE = 50;        // 각도 데드존 (±50도는 전진)
        
        let currentColor = COLORS.stop;
        let newCommand = lastCommand;
        
        // 손이 교차했는지 확인 (왼손이 오른쪽, 오른손이 왼쪽)
        const isCrossed = leftFist.x < rightFist.x;
        
        if (distance < STOP_THRESHOLD || distance < DEADZONE_THRESHOLD) {
          // 정지 영역 또는 데드존
          if (currentSpeed !== 0) {
            currentSpeed = 0;
            newCommand = '정지';
            sendMessage('정지', '5');
            log(`주먉 거리 ${distance.toFixed(2)} → 정지`);
            updateDisplay();
          }
          currentColor = COLORS.stop;
        } else {
          // 움직임 영역
          
          // 거리 변화에 따른 속도 조절
          if (distance > lastDistance + 0.015) {
            if (currentSpeed < 10) {
              currentSpeed++;
              sendMessage('속도증가', '3');
              log(`속도 증가 → ${currentSpeed}단계`);
              updateDisplay();
            }
          } else if (distance < lastDistance - 0.015) {
            if (currentSpeed > 0) {
              currentSpeed--;
              if (currentSpeed === 0) {
                newCommand = '정지';
                sendMessage('정지', '5');
              } else {
                sendMessage('속도감소', '1');
              }
              log(`속도 감소 → ${currentSpeed}단계`);
              updateDisplay();
            }
          }
          
          if (currentSpeed > 0) {
            // 교차 여부로 전진/후진 결정
            if (isCrossed) {
              // 후진
              if (newCommand !== '후진') {
                newCommand = '후진';
                sendMessage('후진', '2');
                log('손 교차 → 후진');
                lastCommand = newCommand;
                updateDisplay();
              }
              currentColor = COLORS.backward;
            } else {
              // 각도 계산
              const angle = getAngle(leftFist, rightFist);
              
              // 디버깅용 로그 (필요시)
              // console.log(`현재 각도: ${angle.toFixed(1)}°`);
              
              if (Math.abs(angle) <= ANGLE_DEADZONE) {
                // 전진 (수평 근처)
                if (newCommand !== '전진') {
                  newCommand = '전진';
                  sendMessage('전진', '8');
                  log(`각도 ${angle.toFixed(1)}° → 전진`);
                  lastCommand = newCommand;
                  updateDisplay();
                }
                currentColor = COLORS.forward;
              } else if (angle > ANGLE_DEADZONE) {
                // 우회전
                if (newCommand !== '우회전') {
                  newCommand = '우회전';
                  sendMessage('우회전', '6');
                  log(`각도 ${angle.toFixed(1)}° → 우회전`);
                  lastCommand = newCommand;
                  updateDisplay();
                }
                currentColor = COLORS.turnRight;
              } else if (angle < -ANGLE_DEADZONE) {
                // 좌회전
                if (newCommand !== '좌회전') {
                  newCommand = '좌회전';
                  sendMessage('좌회전', '4');
                  log(`각도 ${angle.toFixed(1)}° → 좌회전`);
                  lastCommand = newCommand;
                  updateDisplay();
                }
                currentColor = COLORS.turnLeft;
              }
            }
          }
        }
        
        lastDistance = distance;

        // 주먹 점 그리기 (현재 명령 색상)
        const drawFist = (point) => {
          const x = point.x * canvasElement.width;
          const y = point.y * canvasElement.height;
          
          // 외곽 테두리
          canvasCtx.beginPath();
          canvasCtx.arc(x, y, 18, 0, 2 * Math.PI);
          canvasCtx.fillStyle = currentColor;
          canvasCtx.fill();
          
          // 내부 하이라이트
          canvasCtx.beginPath();
          canvasCtx.arc(x - 3, y - 3, 6, 0, 2 * Math.PI);
          canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          canvasCtx.fill();
          
          // 테두리
          canvasCtx.beginPath();
          canvasCtx.arc(x, y, 18, 0, 2 * Math.PI);
          canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
          canvasCtx.lineWidth = 3;
          canvasCtx.stroke();
        };

        drawFist(leftFist);
        drawFist(rightFist);

        // 연결선 그리기
        canvasCtx.beginPath();
        canvasCtx.moveTo(leftFist.x * canvasElement.width, leftFist.y * canvasElement.height);
        canvasCtx.lineTo(rightFist.x * canvasElement.width, rightFist.y * canvasElement.height);
        canvasCtx.strokeStyle = currentColor;
        canvasCtx.lineWidth = 4;
        canvasCtx.setLineDash([10, 5]);
        canvasCtx.stroke();
        canvasCtx.setLineDash([]);
      }

      canvasCtx.restore();
    });

    async function startCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
      videoElement.srcObject = stream;
      videoElement.play();
      videoElement.onloadedmetadata = () => adjustCanvasSize();
    }

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await pose.send({ image: videoElement });
      },
      width: 480,
      height: 640
    });

    window.onload = async () => {
      await startCamera();
      camera.start();

      if (navigator.bluetooth) {
        log('BLE 연결: 화면을 클릭하세요');
        updateStatus('연결 대기 중');
        document.body.addEventListener('click', async () => {
          if (!writeCharacteristic) {
            await connectBLE();
          }
        }, { once: true });
      } else {
        log('이 브라우저는 Web Bluetooth를 지원하지 않습니다');
        updateStatus('미지원');
      }
    };
  </script>

  <div class="footer">
    <hr>
    2025 Teacher Jun, Dept. of Robotics Mechanical Design, Seoul Robotics Highschool
  </div>
</body>
</html>
