<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>웹 AI 포즈 모델 조종기</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: #f2f2f7;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: #1c1c1e;
      margin: 0;
    }

    canvas {
      border-radius: 16px;
      margin-top: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      max-width: 100%;
      width: 100%;
      height: auto;
      display: block;
    }

    #status-box {
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      background-color: #ffffff;
      border: 1px solid #ccc;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
      max-width: 400px;
      width: 100%;
      text-align: center;
      font-size: 0.9em;
    }

    pre#log {
      margin-top: 15px;
      background: #ffffff;
      padding: 14px 18px;
      width: 100%;
      max-width: 400px;
      height: 70px;
      overflow-y: auto;
      border-radius: 12px;
      border: 1px solid #d1d1d6;
      font-size: 0.9em;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
      white-space: pre-wrap;
    }

    video.hidden {
      display: none;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
</head>
<body>
  <h2>웹 AI 포즈 모델 조종기</h2>
  <div id="status-box"><div id="status">화면을 터치하여 기기 검색...</div></div>
  <canvas id="outputCanvas"></canvas>
  <pre id="log"></pre>
  <video id="camera" autoplay playsinline class="hidden"></video>

  <script>
    let device;
    let writeCharacteristic;
    let sentState = { left: false, right: false };
    let lastX8Time = 0;
    let lastX2Time = 0;

    const log = msg => {
      const el = document.getElementById("log");
      el.textContent += msg + "\n";
      el.scrollTop = el.scrollHeight;
    };

    const updateStatus = text => {
      document.getElementById("status").textContent = "상태: " + text;
    };

    async function connectBLE() {
      try {
        device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: ["00c0ffee-1234-1234-1234-123456789abc"]
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService("00c0ffee-1234-1234-1234-123456789abc");
        writeCharacteristic = await service.getCharacteristic("00c0ffee-4321-4321-4321-cba987654321");
        log("BLE 연결 성공: " + device.name);
        updateStatus("연결됨 (" + device.name + ")");

        device.addEventListener("gattserverdisconnected", () => {
          log("BLE 연결 끊김.");
          updateStatus("연결 끊김");
          writeCharacteristic = null;
        });
      } catch (e) {
        log("BLE 연결 실패: " + e);
        updateStatus("연결 실패");
      }
    }

    function sendMessage(label, msg) {
      if (!writeCharacteristic) return;
      const encoder = new TextEncoder();
      writeCharacteristic.writeValue(encoder.encode(msg + "\n"))
        .then(() => log(`[${label}] 전송: ${msg}`))
        .catch(err => log(`[${label}] 전송 실패: ${err}`));
    }

    const videoElement = document.getElementById("camera");
    const canvasElement = document.getElementById("outputCanvas");
    const canvasCtx = canvasElement.getContext("2d");

    function adjustCanvasSize() {
      if (canvasElement.width === 0 || canvasElement.height === 0) {
        if (videoElement.videoWidth && videoElement.videoHeight) {
          canvasElement.width = videoElement.videoWidth;
          canvasElement.height = videoElement.videoHeight;
        }
      }
    }

    function areArmsCrossed(leftWrist, rightWrist) {
      return (
        Math.abs(leftWrist.x - rightWrist.x) < 0.1 &&
        Math.abs(leftWrist.y - rightWrist.y) < 0.1
      );
    }

    const pose = new Pose({
      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    pose.onResults(results => {
      adjustCanvasSize();
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.translate(canvasElement.width, 0);
      canvasCtx.scale(-1, 1);
      canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

      if (results.poseLandmarks) {
        const lm = results.poseLandmarks;
        const leftShoulder = lm[11], rightShoulder = lm[12];
        const leftElbow = lm[13], rightElbow = lm[14];
        const leftWrist = lm[15], rightWrist = lm[16];

        if ([leftWrist, rightWrist].some(p => p.x < 0 || p.x > 1 || p.y < 0 || p.y > 1)) {
          sentState.left = false;
          sentState.right = false;
          lastX2Time = 0;
          lastX8Time = 0;
          log("손이 화면 밖 → 전송 중단");
          canvasCtx.restore();
          return;
        }

        const drawLine = (a, b, color) => {
          canvasCtx.beginPath();
          canvasCtx.moveTo(a.x * canvasElement.width, a.y * canvasElement.height);
          canvasCtx.lineTo(b.x * canvasElement.width, b.y * canvasElement.height);
          canvasCtx.strokeStyle = color;
          canvasCtx.lineWidth = 2;
          canvasCtx.stroke();
        };

        const drawPoint = (p, color) => {
          canvasCtx.beginPath();
          canvasCtx.arc(p.x * canvasElement.width, p.y * canvasElement.height, 5, 0, 2 * Math.PI);
          canvasCtx.fillStyle = color;
          canvasCtx.fill();
        };

        // Draw arms only
        drawLine(leftShoulder, leftElbow, '#FF0000');
        drawLine(leftElbow, leftWrist, '#FF0000');
        drawLine(rightShoulder, rightElbow, '#0000FF');
        drawLine(rightElbow, rightWrist, '#0000FF');
        drawLine(leftShoulder, rightShoulder, '#00FF00');

        [leftShoulder, rightShoulder, leftElbow, rightElbow, leftWrist, rightWrist].forEach(p => drawPoint(p, '#FF8800'));

        const shoulderY = (leftShoulder.y + rightShoulder.y) / 2 * canvasElement.height;

        if (!sentState.left && leftWrist.y * canvasElement.height < shoulderY) {
          sendMessage('LEFT', '4');
          sentState.left = true;
          log('왼손 위로 올림 → 4 전송');
        } else if (leftWrist.y * canvasElement.height > shoulderY + 20) {
          sentState.left = false;
        }

        if (!sentState.right && rightWrist.y * canvasElement.height < shoulderY) {
          sendMessage('RIGHT', '6');
          sentState.right = true;
          log('오른손 위로 올림 → 6 전송');
        } else if (rightWrist.y * canvasElement.height > shoulderY + 20) {
          sentState.right = false;
        }

        const isCrossed = areArmsCrossed(leftWrist, rightWrist);
        const avgY = (leftWrist.y + rightWrist.y) / 2 * canvasElement.height;
        const centerY = canvasElement.height / 2;
        const now = Date.now();

        if (isCrossed && avgY > centerY && now - lastX8Time > 500) {
          sendMessage('하단 교차', '8');
          lastX8Time = now;
          log('하단 교차 → 8 전송');
        } else if (isCrossed && avgY < centerY && now - lastX2Time > 500) {
          sendMessage('상단 교차', '2');
          lastX2Time = now;
          log('상단 교차 → 2 전송');
        }
      }

      canvasCtx.restore();
    });

    async function startCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
      videoElement.srcObject = stream;
      videoElement.play();

      videoElement.onloadedmetadata = () => {
        adjustCanvasSize();
        camera.start();
      };
    }

    const camera = new Camera(videoElement, {
      onFrame: async () => await pose.send({ image: videoElement }),
      width: 480,
      height: 640
    });

    window.onload = async () => {
      await startCamera();

      if (navigator.bluetooth) {
        log('BLE를 연결하려면 화면을 클릭하세요.');
        updateStatus('연결 대기 중');
        document.body.addEventListener('click', async () => {
          if (!writeCharacteristic) await connectBLE();
        }, { once: true });
      } else {
        log('이 브라우저는 Web Bluetooth를 지원하지 않습니다.');
        updateStatus('미지원');
      }
    };
  </script>

  <div style="width: 100%; max-width: 400px; text-align: center; padding: 10px 0; margin-top: 20px; font-size: 0.8em; color: #8e8e93;">
    <hr style="border: none; border-top: 1px solid #d1d1d6; margin: 10px 0;">
    2025 Teacher Jun, Dept. of Robotics Mechanical Design, Seoul Robotics Highschool
  </div>
</body>
</html>
