<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>웹 AI 포즈 모델 조종기</title>
  <style>
    /* 기존 스타일 그대로 유지 */
    body { /* ... */ }
    .main-container { /* ... */ }
    /* 이하 생략 */
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
</head>
<body>
  <h2>웹 AI 포즈 모델 조종기</h2>
  <div id="status-box">
    <div id="status">화면을 터치하여 기기 검색...</div>
  </div>
  <canvas id="outputCanvas"></canvas>
  <pre id="log"></pre>
  <video id="camera" autoplay playsinline class="hidden"></video>

  <script>
    let device;
    let writeCharacteristic;
    let sentState = { left: false, right: false };

    // --- 추가: 전송 일시중지 플래그 & 근접 전송 인터벌 변수
    let pauseTransmission = false;
    let proximityInterval = null;
    let proximityDirection = null;

    const log = (msg) => {
      const el = document.getElementById('log');
      el.textContent += msg + '\n';
      el.scrollTop = el.scrollHeight;
    };
    const updateStatus = (text) => {
      document.getElementById('status').textContent = '상태: ' + text;
    };

    async function connectBLE() { /* 기존 BLE 연결 로직 */ }

    function sendMessage(label, msg) {
      if (!writeCharacteristic) return;
      const encoder = new TextEncoder();
      writeCharacteristic.writeValue(encoder.encode(msg + '\n'))
        .then(() => log(`[${label}] 전송: ${msg}`))
        .catch(err => log(`[${label}] 전송 실패: ${err}`));
    }

    const videoElement = document.getElementById('camera');
    const canvasElement = document.getElementById('outputCanvas');
    const canvasCtx = canvasElement.getContext('2d');

    function adjustCanvasSize() {
      if (videoElement.videoWidth && videoElement.videoHeight) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
      }
    }

    // --- 추가: 근접 인터벌 해제 함수
    function clearProximityInterval() {
      if (proximityInterval) {
        clearInterval(proximityInterval);
        proximityInterval = null;
        proximityDirection = null;
      }
    }

    const pose = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });
    pose.setOptions({ /* 기존 옵션 */ });

    pose.onResults(results => {
      adjustCanvasSize();
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.translate(canvasElement.width, 0);
      canvasCtx.scale(-1, 1);
      canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

      if (results.poseLandmarks) {
        const landmarks = results.poseLandmarks;
        const leftShoulder = landmarks[11];
        const rightShoulder = landmarks[12];
        const leftElbow = landmarks[13];
        const rightElbow = landmarks[14];
        const leftWrist = landmarks[15];
        const rightWrist = landmarks[16];

        // 화면 밖 판정
        const outOfBounds =
          leftWrist.x < 0 || leftWrist.x > 1 || leftWrist.y < 0 || leftWrist.y > 1 ||
          rightWrist.x < 0 || rightWrist.x > 1 || rightWrist.y < 0 || rightWrist.y > 1;

        if (outOfBounds) {
          if (!pauseTransmission) {
            pauseTransmission = true;
            clearProximityInterval();
            log('⚠️ 주먹이 화면 밖으로 벗어남 → 전송 중지');
          }
          canvasCtx.restore();
          return;
        } else if (pauseTransmission) {
          pauseTransmission = false;
          log('✅ 주먹이 화면 안으로 복귀 → 전송 재개');
        }

        // 랜드마크 선 그리기 (기존)
        const drawLine = (a, b, color) => {
          canvasCtx.beginPath();
          canvasCtx.moveTo(a.x * canvasElement.width, a.y * canvasElement.height);
          canvasCtx.lineTo(b.x * canvasElement.width, b.y * canvasElement.height);
          canvasCtx.strokeStyle = color;
          canvasCtx.lineWidth = 4;
          canvasCtx.stroke();
        };
        drawLine(leftShoulder, rightShoulder, '#00FF00');
        drawLine(leftShoulder, leftElbow, '#FF0000');
        drawLine(leftElbow, leftWrist, '#FF0000');
        drawLine(rightShoulder, rightElbow, '#0000FF');
        drawLine(rightElbow, rightWrist, '#0000FF');

        const shoulderY = (leftShoulder.y + rightShoulder.y) / 2 * canvasElement.height;

        // 4·6 전송 로직 (기존)
        if (!pauseTransmission) {
          if (!sentState.left && leftWrist.y * canvasElement.height < shoulderY) {
            sendMessage('LEFT', '4');
            sentState.left = true;
            log('왼손 위로 올림 → 4 전송');
          } else if (leftWrist.y * canvasElement.height > shoulderY + 20) {
            sentState.left = false;
          }
          if (!sentState.right && rightWrist.y * canvasElement.height < shoulderY) {
            sendMessage('RIGHT', '6');
            sentState.right = true;
            log('오른손 위로 올림 → 6 전송');
          } else if (rightWrist.y * canvasElement.height > shoulderY + 20) {
            sentState.right = false;
          }
        }

        // --- 추가: 주먹 근접(8/2) 전송 로직
        if (!pauseTransmission) {
          const x1 = leftWrist.x * canvasElement.width;
          const y1 = leftWrist.y * canvasElement.height;
          const x2 = rightWrist.x * canvasElement.width;
          const y2 = rightWrist.y * canvasElement.height;
          const dist = Math.hypot(x1 - x2, y1 - y2);
          const closeThreshold = 60;  // 픽셀 단위 임계치

          if (dist < closeThreshold) {
            const avgY = (y1 + y2) / 2;
            const region = (avgY > canvasElement.height / 2) ? 'bottom' : 'top';
            const msg = region === 'bottom' ? '8' : '2';

            if (!proximityInterval || proximityDirection !== region) {
              clearProximityInterval();
              proximityDirection = region;
              sendMessage('PROX', msg);
              proximityInterval = setInterval(() => {
                if (!pauseTransmission) sendMessage('PROX', msg);
              }, 500);
              log(`✋ 주먹 근접 → ${msg} 전송(연속)`);
            }
          } else {
            if (proximityInterval) {
              clearProximityInterval();
              log('🤝 주먹 분리 → 근접 전송 중단');
            }
          }
        }
      }

      canvasCtx.restore();
    });

    async function startCamera() { /* 기존 */ }
    const camera = new Camera(videoElement, { /* 기존 */ });

    window.onload = async () => {
      await startCamera();
      camera.start();
      if (navigator.bluetooth) {
        log('BLE를 연결하려면 화면을 클릭하세요.');
        updateStatus('연결 대기 중');
        document.body.addEventListener('click', async () => {
          if (!writeCharacteristic) await connectBLE();
        }, { once: true });
      } else {
        log('이 브라우저는 Web Bluetooth를 지원하지 않습니다.');
        updateStatus('미지원');
      }
    };
  </script>

  <div style="/* Footer */">
    2025 Teacher Jun, Dept. of Robotics Mechanical Design, Seoul Robotics Highschool
  </div>
</body>
</html>
